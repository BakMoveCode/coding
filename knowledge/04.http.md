# HTTP

https://github.com/Advanced-Interview-Question/front-end-interview/blob/dev/docs/guide/http.md

https://zhuanlan.zhihu.com/p/86426969

https://github.com/ljianshu/Blog/issues/50

https://mp.weixin.qq.com/s/ph1kMOaJNbpMoP7IaCn5XA

https://mp.weixin.qq.com/s/oRGE2KA7bsfhoIboqrmGkA

## HTTP 协议由哪些方法？

GET，用通常于请求服务器发送某些资源
POST，发送数据给服务器
HEAD，请求资源的头部信息，并且这些头部与 http get 方法请求时返回的一致。该请求方法的一个使用场景是在下载一个大文件前县获取其大小再决定是否要下载以此可以节约宽带资源。
OPTIONS，用于获取目的资源所支持的通信选项
PUT，用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
DELETE，用于删除指定的资源
PATCH，用于对资源进行部分修改
CONNECT，http1.1 协议中预留给能够将连接改为管道方式的代理服务器
TRACE，用显服务器收到的请求，主要用于测试或者诊断

GET 和 POST 的区别：

1. 数据传输方式不同：GET 请求通过 URL 传输数据，而 POST 的数据通过请求体传输
2. 安全性不同：POST 的数据因为在请求主体内，所以由一定的安全性保证，而 GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息
3. 数据类型不同：GET 只允许 ASCII 字符，而 POST 无限制
4. GET 无害：刷新，后退等浏览器操作 GET 请求是无害的，POST 可能重复提交表单
5. 特性不同：GET 是安全（这里的安全是指只读性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念就是指同一个请求方法执行多次和仅仅执行以此的效果完全相同），而 POST 是非安全非幂等

PUT 和 POST 都是给服务器发送新增资源，区别是什么？

PUT 和 PATCH 都是给服务器发送修改资源，区别是什么？

## http 的请求报文是什么样的？

1. 请求报文由 4 部分组成

- 请求行（请求方法，URL 字段，http 协议版本）
- 请求头部，请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号：分隔
- 空行
- 请求体

2. 响应报文由 4 部分组成

- 响应行（协议，版本，状态码，状态码的原因短语）
- 响应头
- 空行
- 响应体

## HTTP 的状态码由哪些

1XX 服务器接受请求
2XX 成功
3XX 重定向
4XX 客户端错误
5XX 服务器错误

详细清单：

1XX：

- 100

2XX：

- 200
- 201

3XX：

- 200
- 201

4XX：

- 200
- 201

5XX：

- 200
- 201

## http 的发展历程

1. http/0.9，没有 header 等描述数据的信息，只规定了客户端和服务端的通信形式，只支持 GET 请求
2. http/1.0，正式成为标准，传输内容格式不限制，增加了 put，patch，head，options，delete 命令
3. http/1.1，增加了持久连接和管道机制
4. http/2，增加了多路复用，服务端推送，头部压缩，二进制帧数据传输等

## 什么是 keep-alive（持久连接）

keep-alive 允许在一定时间内，同一个域名多次请求数据，只建立一次 http 链接，其他请求可以复用这个连接通道，以达到提高请求效率的目的

如果没有设置此属性，那么每次请求都要建立连接，请求完成后马上关闭连接，也就是三次握手和四次挥手，带来资源的浪费

## 管道机制的作用是什么？

https://mp.weixin.qq.com/s/ph1kMOaJNbpMoP7IaCn5XA

## 深入理解 HTTPS 工作原理

HTTPS 相比于 HTTP 的区别：

1. 密文传输
2. 安全性，证书与数字签名
3. 数据一致性（数据完整性）
4. https 的端口是 443，http 的端口是 80

## HTTPS

加密：
（解决内容可能被窃听的问题，https 采用的是对称加密+非对称加密）

1. 非对称加密（RSA）
2. 对称加密（AES）
3. MD5 加密（散列算法）

数字签名功能：
（解决报文可能遭修改问题）

1. 能确定消息是由发送方签名并发出来的
2. 数字签名能确定消息的完整性，证明数据是否未被修改过

数字证书：
（解决通信方身份可能被伪装的问题）

缺点：
与纯文本通信相比，加密通信会消耗更多的 CPU 以及内存资源
证书是需要进行购买的

## HTTPS 的握手过程

简单过程：

1. 客户端发起请求，服务端响应给用户端证书，证书中包含公钥
2. 客户端接收到证书后，生成随机数，通过公钥加密，将随机数发送给服务端，并凭随机数构造对称加密和服务端通信，并告知服务端此次通信后的通信都将使用随机数密钥
3. 服务端使用私钥解析随机数，并通过随机数构造对称加密算法，同样告知客户端之后的请求将使用随机数进行加密

## 讲解 HTPPS 对称加密和非对称加密

对称加密，

- 指的是加密和解密使用同一个密钥，

非对称加密，

- 加密和解密使用不同的密钥，一把作为公开的公钥，另外一把作为私钥。
- 公钥进行加密信息，只有私钥才能解密

1. 握手阶段，https 在证书验证阶段，使用非对称加密来传输共享密钥，
2. 传输数据阶段，采用的是对称加密方式

## 介绍下 HTTPS 中间人攻击的过程（为什么需要 CA 认证机构颁发证书？）

中间人攻击的过程：

1. 客户端请求被劫持，将所有的请求发送到中间人的服务器
2. 中间人服务器返回自己的证书
3. 客户端创建随机数，使用中间人证书中的公钥进行加密发送给中间人服务器，中间人使用
   私钥对随机数解密并构造对称加密，对之后传输的内容进行加密传输
4. 中间人通过客户端的随机数对客户端的数据进行解密
5. 中间人与服务器建立合法的 https 链接（http 握手过程），与服务端之间使用对称加密进行数据传输，拿到服务端的响应数据，并通过与服务端建立的对称加密密钥进行解密
6. 中间人再通过与客户端建立的对称加密对响应数据进行加密后传输给客户端
7. 客户端通过与中间人建立的对称加密的密钥对数据进行解密

总结：

1. 中间人攻击中，中间人首先伪装成服务端和客户端通信，
2. 然后又伪装成客户端与服务端进行通信。
3. 整个过程中，由于缺少了证书的验证过程，虽然使用了 https，但是传输的数据已经被监听，客户端却无法得知

## HTTPS 握手过程中，客户端如何验证证书的合法性

CA 证书中会包含颁发机构信息，公钥，公司信息，域名，有效期等信息

浏览器验证证书：

1. 首先验证域名，有效期等信息是否正确
2. 判断证书来源的合法性
3. 判断证书是否被修改，需要与 CS 服务器进行校验
4. 判断证书是否已经吊销

## HTTP2/HTTP3 特性

https://github.com/ljianshu/Blog/issues/57

HTTP1.X 的缺点：

1. 高延迟 - 带来页面加载速度降低
   （网络延迟问题主要由于队头阻塞，导致带宽无法被充分利用）
2. 无状态特性 - 带来的巨大的 HTTP 头部
3. 明文传输 - 带来的不安全性
4. 不支持服务器推送消息

HTTP2 的特点：

1. 二进制分帧
   http1.x 采用的是文本格式传输，
   http2 采用二进制格式传输数据，二进制协议解析起来更高效

2. 头部压缩
   http1.x 会在请求和响应中重复地携带不常改变，冗长的头部数据，给网络带来额外的负担
   http2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，
   对于相同的数据不再通过每次请求和响应发送。
   首部表在 http2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新；
   每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值
   只发送差异数据，而不是全部发送，从而减少头部的信息量

3. 多路复用
   （解决浏览器限制同一个域名下的请求数量的访问限制）
   http1.x 中，如果想并发多个请求，必须使用多个 TCP 连接，而且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制
   http2 中，
   同域名下所有通信都在单个连接上完成，
   单个连接可以承载任意数量的双向数据流，
   数据流以消息的形式发送，而消息又由一个或多个帧组成多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装

4. 服务器推送
   服务端可以在发送页面 html 时主动推送其他资源，而不用等到浏览器解析到相应位置，发起请求再响应
   服务端可以主动推送，客户端也由权利选择是否接收。
   主动推送也遵守同源策略

## 如何保证页面文件能被完整送达浏览器

## 跨域

1. JSONP
2. CORS
3. windows.postMessage
4. Nginx 的反向代理

## web 实时推送技术的总结

1. 短轮询
2. 长轮询
3. websocket
4. SSE

基本传输过程：

1. 上层将数据包叫给传输层
2. 传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层
3. 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层
4. 数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层
5. 在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序
6. 最终，数据包就发送到了主机 B 上层应用程序这里

## TCP 的三次握手和 TCP 的四次挥手

## TCP 和 UDP 的区别

https://github.com/ljianshu/Blog/issues/61

TCP/IP 模型是互联网的基础，是一系列网络协议的总称。
分为四层：

1. 链路层，负责封装和解封装 IP 报文，发送和接收 ARP/RARP 报文等
2. 网络层，负责路由以及把分组报文发送给目标网络或主机
3. 传输层，负责对报文进行分组和重组，并以 TCP 和 UDP 协议格式封装报文
4. 应用层，负责向用户提供应用程序，比如 HTTP，FTP，Telent，DNS，SMTP 等。

UDP

1. 面向无连接
2. 由单播，多播，广播的功能
3. UDP 是面向报文的
4. 不可靠性
5. 头部开销小，传输数据报文时是很高效的

TCP

1. 面向连接
2. 仅支持单播传输
3. 面向字节流
4. 可靠传输
5. 提供拥塞控制
6. TCP 提供全双工通信

总结

1. TCP 向上层提供面向连接的可靠服务，UDP 向上层提供无连接不可靠服务
2. 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
3. 对数据准确性要求高，速度可以相对较慢的，可以选用 TCP
