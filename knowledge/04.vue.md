# VUE

## Vue 的响应式原理

1. Vue2.0 的 object.defineProperty，通过 getter 和 setter 对对象的属性进行代理，当代理对象中的某个值被访问或者重新赋值就会触发相应的 get 和 set 方法。
   注意：
   对数组的代理，vue2.0 是直接重新数组的原型方法来进行监听的，比如直接修改数组的长度，是不能进行绑定的
2. Vue3 的 Proxy，直接对对象进行代理
   注意：
   可直接对数组进行代理，
   如果是数组里的是对象，也需要进行深层次的绑定
   优点：
   数组变化也能监听到
   不需要深度遍历监听

## Vue 中的双向绑定原理和依赖收集原理

## Virtual DOM

原因：DOM 引擎与 JS 引擎相互独立，同时又工作在同一个线程上。JS 代码调用 DOM API 必须挂起 JS 引擎，转换传入参数数据，激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 殷勤并继续执行。若有频繁的 DOM API 调用，重新计算布局，重新绘制图像会引起更大的性能消耗。

VDOM 和真实 DOM 的区别和优化：

1. 虚拟 DOM 不会立马进行排版与重绘操作
2. 虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要修改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘消耗
3. 虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部

## diff 算法

实现步骤：
用 JavaScript 对象模拟 DOM
把此虚拟 DOM 转成真实 DOM 并插入页面中
如果有事件发生修改了虚拟 DOM
比较两棵虚拟 DOM 树的差异，得到差异对象
把差异对象应用到真正的 DOM 树上

DOM DIFF：
比较两颗 DOM 树的差异是虚拟 DOM 的算法的核心，简单的说就是新旧虚拟 DOM 的比较

比较只会在同层级进行，不会跨层级比较：
比较后会出现四种情况：

1. 此节点是否被移除 --> 添加新的节点
2. 属性是否被改变 --> 旧属性改为新属性
3. 文本内容被改变 --> 旧被人改为新内容
4. 节点要被整个替换 --> 结构完全不相同 移除整个替换

在同层级进行比较的时候，会使用 key 进行比较，就地复用

总结：

1. 会先进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的 key 与旧节点进行比对，

## 如何事件 component

## 组件间通信

1. 子向父：props 和 \$emit
2. 父向子：\$refs
3. 兄弟：$parent 和 $child
4. 跨级组件通信：provide/inject
5. 任意组件：vuex

## Vuex

是一个全局集中响应式状态的管理工具，状态会保存在 state 内，可以被所有组件所引用，一经修改后引用 state 内状态的组件都会响应式的更新。

state 不能被直接修改，必须 commit 内提交 mutation 才行，而且 mutation 必须是同步函数。
提交 action 可以在内部进行异步操作，可同时提交多个 mutation

state：状态中心
mutations：更改状态，同步改变状态
commit，对状态改变提交操作方法
actions：异步更改状态，异步的改变 state 状态
getters：获取状态
modules：将 state 分成多个 modules，便于管理

总结：
vuex 是 vue 应用中多个组件的共享状态进行集中式的管理

## Vue-router

1. hash 模式
2. history 模式

## Vue Hook

hook 是什么？

Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。
那么 vue 提供的这些 API 的作用也是类似的--可以让你在函数组件里“钩入” value(2.x 中的 data) 及生命周期等特性的函数

hook 的使用：
把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新

hook 的优点：

1. 逻辑代码的复用
2. 减小了代码体积
3. 没有 this 的烦恼

mixin 的问题：

1. 可能会相互依赖，相互耦合，不利于代码维护，被引用的组件中的方法会重写 mixin 中的
2. 不同的 mixin 中的方法可能会相互冲突？
3. mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性。

hook 实现了 mixins 的功能，但是避免了 mixins 带来的两个主要问题：

1. 允许相互传递状态
2. 明确指出逻辑来自哪里。

## SSR（服务端渲染）

服务端渲染：直接在服务端层回去数据，渲染出完成的 HTML 文件，直接返回给用户浏览器。

前后端分离：前端与服务端隔离，前端动态获取数据，渲染页面

痛点：

1. 首屏渲染性能瓶颈
   空白延迟：HTML 下载时间 + JS 下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。
2. SEO 问题
   由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好

## Vue 的生命周期

分为 4 类：

1. beforeCreate
2. create
3. beforeMounted
4. mounted
5. beforeUpdate
6. update
7. activited
8. deadactived
9. beforeDestory
10. destory

## keep-alive

被 keep-alive 包裹的组件，不会被销毁，也不会重建，会被保存在内存中。

缓存后的组件的生命周期是使用 actived 和 deactivated

## Vue 的懒加载和延迟加载

## Vue computed 的原理

## Vue 中 computed 和 watched 的区别

computed：

1. 计算属性，也就是计算值，更多用于计算值的场景
2. 具有缓存性，computed 的值在 getter 执行后是会缓存的，只有在它依赖的属性值改变之后，
   下一次获取 computed 的值时才会重新调用对应的 getter 计算属性
3. 适用于计算比较消耗性能的计算场景

watched：

1. 观察作用，类似与对数据的监听回调
2. 无缓存性

## 循环渲染中的 key 有什么作用

## prefetch 和 preload

## nextTick 方法是怎么实现的

## EventBUS 传输数据是同步还是异步的

## 如何进行组件的封装

## 子组件为什么不可以修改父组件传递的 prop

## 常用链接

https://mp.weixin.qq.com/s/9vodHluC5k1fOcZfn_bJ2A
