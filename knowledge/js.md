# Javascript

##### 原型和原型链

##### this

谁调用的函数就是，this 就指向谁。

##### JS 执行上下文

执行上下文就是当前 JS 代码被解析和执行时所在环境的抽象概念，JS 中运行任何的代码都是在执行上下文中执行。

类型：

- 全局执行上下文
- 函数执行上下文

执行上下文创建过程中，需要做以下几件事情：

1. 创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。
2. 创建作用域链：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的
3. 确定 this 的值

##### 作用域

作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规定，确定当前执行的
代码对这些标识符的访问权限。
JS 采用词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定。

作用域分为：

1. 全局作用域
2. 函数作用域
3. 块级作用域

##### 执行上下文栈

执行栈，也叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。

规则：

1. 首次运行 JS 代码的时候，会创建一个全局执行的上下文并 push 到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并朴实当前执行栈的栈顶
2. 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中 POP 出，上下文的控制权将移动到当前执行栈的下一个执行上下文

##### 作用域链

作用域就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没有找到，宣布放弃。这种一层一层的关系，就是作用域链。

##### 闭包

定义：

1. JS 高级程序设计：闭包是指有权访问另一个函数作用域中的变量的函数
2. 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
3. 闭包使得函数可以继续访问定义时的词法作用域。

闭包的作用：

1. 能够访问函数定义时所在的词法作用域（阻止其被回收）
2. 私有化变量
3. 模拟块级作用域
4. 创建模块

##### 类数组对象与 Arguments

##### 偏函数

##### 惰性函数

##### 函数组合和函数记忆

##### 创建对象的多种方式以及优缺点

##### 继承的多种方式以及优缺点

##### new 的实现原理是什么？

1. 创建一个空对象，构造函数中的 this 指向这个空对象
2. 这个新对象的原型指向构造函数的原型
3. 执行构造函数方法，属性和方法被添加到 this 引用的对象中
4. 如果构造函数中没有返回其他对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象。

##### 如何正确判断 this 的指向

总结：谁调用它，this 就指向谁。

全局环境中的 this：
无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 Window；

node 环境：
无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象「」

是否是 new 绑定：
如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。

箭头函数：
箭头函数没有自己的 this，继承外层上下文绑定的 this

##### 深拷贝和浅拷贝的区别是什么？实现一个深拷贝？

深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝

个人解释：
浅拷贝只拷贝栈内存中的地址，
深拷贝会将堆内存内存中的地址也拷贝一份

浅拷贝：
浅拷贝是会将对象的每个属性进行衣服复制，但是当对象的属性值是引用类型时，实质
复制的是其引用，当引用指向的值改变时也会跟着变化
只对第一层属性进行拷贝。当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性其指向的是同一块内存地址。

可使用 Object.assign，扩展运算符...，Array.prototype.slice()，Array。prototype。concat（）

深拷贝：
深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。
深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。

深拷贝实现：

1. 最简单的实现是 JSON.parse(JSON.stringify(obj))
   缺点：

   - 对象的属性值是函数时，无法拷贝
   - 原型链上的属性无法拷贝
   - 不能正确的处理 Date 类型的数据
   - 不能处理 RegExp
   - 会忽略 symbol
   - 会忽略 undefined

2. 实现一个 deepClone 函数
   - 如果是基本数据类型，直接返回
   - 如果是 RegExp 或者 Date 类型，返回对应类型
   - 如果是负责数据类型，递归
   - 考虑循环引用的问题
   - 如果是函数，使用 eval

##### call/apply 的实现原理是什么？

call 和 apply 的功能相同，都是改变 this 的执行，并立即执行函数。
区别在于传参数方式不同。

func.call(thisArg, arg1, arg2, ...): 第一个参数是 this 指向的对象，其他参数依次传入

func.apply(thisArg, [argsArray]): 第一个参数是 this 指向的对象，第二个参数是数组或者类似数组

##### 柯里化函数实现

函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

主要作用：

1. 参数复用
2. 提前返回 - 返回接受余下的参数且返回结果的新函数
3. 延迟执行 - 返回新函数，等待执行

##### 如何让（a ==1 && a==2&& a==3）的值为 true ？

（https://mp.weixin.qq.com/s/oDZTiplBVubpi7TCehAKbA）

1. 利用隐式类型转换
2. 利用数据劫持（Proxy / Obejct.definedProperty）
3. 利用数组的 toString 接口默认调用数组的 join 方法，重新 join 方法

##### 异步加载 JS 脚本的方式有哪些？

script 标签中增加 async（html5）或者 defer（html4）属性，脚本就会异步加载

defer 和 async 的区别：

1. defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成）。在 window。。onload 之前执行
2. async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
3. 如果有多个 defer 脚本，会按照它们在页面出现的顺序加载
4. 多哥 async 脚本不能保证加载顺序

##### ES5 有几种方式可以实现继承？分别有哪些优缺点？

1. 原型链继承
   基本思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法

缺点：

- tong

2. 借用构造函数
   基本思想是在子类型的构造函数中调用超类型构造函数
   优点：

- 可以向超类型传递参数
- 解决了原型中包含引用类型值被所有实例共享的问题

缺点：

- 方法都在构造函数中，多次调用

3. 组合继承（原型链+ 借用构造函数）
   是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。
   基本思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。
   即通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性

4. 原型式继承
   基本思想是借用原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。

5. 寄生式继承

6. 寄生组合式继承
