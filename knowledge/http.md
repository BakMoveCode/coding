# HTTP

https://github.com/Advanced-Interview-Question/front-end-interview/blob/dev/docs/guide/http.md

https://zhuanlan.zhihu.com/p/86426969

https://github.com/ljianshu/Blog/issues/50

## HTTP 协议由哪些方法？

GET，用通常于请求服务器发送某些资源
POST，发送数据给服务器
HEAD，请求资源的头部信息，并且这些头部与 http get 方法请求时返回的一致。该请求方法的一个使用场景是在下载一个大文件前县获取其大小再决定是否要下载以此可以节约宽带资源。
OPTIONS，用于获取目的资源所支持的通信选项
PUT，用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
DELETE，用于删除指定的资源
PATCH，用于对资源进行部分修改
CONNECT，http1.1 协议中预留给能够将连接改为管道方式的代理服务器
TRACE，用显服务器收到的请求，主要用于测试或者诊断

GET 和 POST 的区别：

1. 数据传输方式不同：GET 请求通过 URL 传输数据，而 POST 的数据通过请求体传输
2. 安全性不同：POST 的数据因为在请求主体内，所以由一定的安全性保证，而 GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息
3. 数据类型不同：GET 只允许 ASCII 字符，而 POST 无限制
4. GET 无害：刷新，后退等浏览器操作 GET 请求是无害的，POST 可能重复提交表单
5. 特性不同：GET 是安全（这里的安全是指只读性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念就是指同一个请求方法执行多次和仅仅执行以此的效果完全相同），而 POST 是非安全非幂等

PUT 和 POST 都是给服务器发送新增资源，区别是什么？

PUT 和 PATCH 都是给服务器发送修改资源，区别是什么？

## http 的请求报文是什么样的？

1. 请求报文由 4 部分组成

- 请求行（请求方法，URL 字段，http 协议版本）
- 请求头部，请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号：分隔
- 空行
- 请求体

2. 响应报文由 4 部分组成

- 响应行（协议，版本，状态码，状态码的原因短语）
- 响应头
- 空行
- 响应体

## HTTP 的状态码由哪些

1XX 服务器接受请求
2XX 成功
3XX 重定向
4XX 客户端错误
5XX 服务器错误

## 深入理解 HTTPS 工作原理

HTTPS 相比于 HTTP 的优点：

1. 密文传输
2. 安全性，证书与数字签名
3. 数据一致性

## HTTPS

加密：
（解决内容可能被窃听的问题，https 采用的是对称加密+非对称加密）

1. 非对称加密（RSA）
2. 对称加密（AES）
3. MD5 加密（散列算法）

数字签名功能：
（解决报文可能遭修改问题）

1. 能确定消息是由发送方签名并发出来的
2. 数字签名能确定消息的完整性，证明数据是否未被修改过

数字证书：
（解决通信方身份可能被伪装的问题）

缺点：
与纯文本通信相比，加密通信会消耗更多的 CPU 以及内存资源
证书是需要进行购买的

## HTTP2/HTTP3 特性

https://github.com/ljianshu/Blog/issues/57

HTTP1.X 的缺点：

1. 高延迟 - 带来页面加载速度降低
   （网络延迟问题主要由于队头阻塞，导致带宽无法被充分利用）
2. 无状态特性 - 带来的巨大的 HTTP 头部
3. 明文传输 - 带来的不安全性
4. 不支持服务器推送消息

HTTP2 的特点：

1. 二进制分帧
   http1.x 采用的是文本格式传输，
   http2 采用二进制格式传输数据，二进制协议解析起来更高效

2. 头部压缩
   http1.x 会在请求和响应中重复地携带不常改变，冗长的头部数据，给网络带来额外的负担
   http2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，
   对于相同的数据不再通过每次请求和响应发送。
   首部表在 http2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新；
   每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值
   只发送差异数据，而不是全部发送，从而减少头部的信息量

3. 多路复用
   （解决浏览器限制同一个域名下的请求数量的访问限制）
   http1.x 中，如果想并发多个请求，必须使用多个 TCP 连接，而且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制
   http2 中，
   同域名下所有通信都在单个连接上完成，
   单个连接可以承载任意数量的双向数据流，
   数据流以消息的形式发送，而消息又由一个或多个帧组成多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装

4. 服务器推送
   服务端可以在发送页面 html 时主动推送其他资源，而不用等到浏览器解析到相应位置，发起请求再响应
   服务端可以主动推送，客户端也由权利选择是否接收。
   主动推送也遵守同源策略

## 跨域

1. JSONP
2. CORS
3. windows.postMessage
4. Nginx 的反向代理

## web 实时推送技术的总结

1. 短轮询
2. 长轮询
3. websocket
4. SSE

## 讲解 HTPPS 对称加密和非对称加密

## 如何保证页面文件能被完整送达浏览器

基本传输过程：

1. 上层将数据包叫给传输层
2. 传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层
3. 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层
4. 数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层
5. 在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序
6. 最终，数据包就发送到了主机 B 上层应用程序这里

## TCP 的三次握手和 TCP 的四次挥手

## 为什么很多站点第二次打开速度会很快？

https://mp.weixin.qq.com/s/klZ6j3Gj9cwHGQFys6Hdjg

主要原因是第一次加载页面过程中，缓存了一些耗时的数据。

1. DNS 缓存
   在浏览器本地把对应的 IP 和域名关联起来，这样在 DNS 解析的时候就很快

2. MemoryCache
   是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。
   当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在

3. 浏览器缓存
   分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。

   强缓存
   强缓存是利用 http 头中的 expires 和 cache-control 来控制的。
   当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，不会再与服务端发送通信。
   cache-control 中通过 max-age 来控制资源的有效期。

   协商缓存
   协商缓存依赖与服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器校验资源的新鲜度。
   若网络请求对应的状态码是 304，则表示服务端提示缓存资源未改动，会获取浏览器缓存中的数据

   1. Last-Modified（If-Modified-Since）

   - 存在问题是服务器并没有正确感知文件的变化，会存在资源校验失效的情况。

   2. Etag（If-None-Match）

   - 由服务器是基于文件内容编码为每一个资源生成的唯一标识字符串，能够精确地感知文件的变化。
   - etag 的生成过程需要服务器额外付出开销，会影响服务端的性能。

4. Service Worker Cache

   是一种独立于主线程之外的 JS 线程，脱离来浏览器窗体，因此无法直接访问 DOM。
   可以实现离线缓存，消息推送和网络代理等功能。

   Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件.

5. Push Cache

## TCP 和 UDP 的区别

TCP/IP 模型是互联网的基础，是一系列网络协议的总称。
分为四层：

1. 链路层，负责封装和解封装 IP 报文，发送和接收 ARP/RARP 报文等
2. 网络层，负责路由以及把分组报文发送给目标网络或主机
3. 传输层，负责对报文进行分组和重组，并以 TCP 和 UDP 协议格式封装报文
4. 应用层，负责向用户提供应用程序，比如 HTTP，FTP，Telent，DNS，SMTP 等。

UDP

1. 面向无连接
2. 由单播，多播，广播的功能
3. UDP 是面向报文的
4. 不可靠性
5. 头部开销小，传输数据报文时是很高效的

TCP

1. 面向连接
2. 仅支持单播传输
3. 面向字节流
4. 可靠传输
5. 提供拥塞控制
6. TCP 提供全双工通信

总结

1. TCP 向上层提供面向连接的可靠服务，UDP 向上层提供无连接不可靠服务
2. 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
3. 对数据准确性要求高，速度可以相对较慢的，可以选用 TCP
